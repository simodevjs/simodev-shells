#!/bin/bash

# Define color codes
BLUE='\033[0;34m'
BLINK_RED='\033[5;31m'
NC='\033[0m' # No Color

# Function to generate checksum
generate_checksum() {
    echo -e "${BLUE}Generating checksum for $1...${NC}"
    shasum -a 256 "$1" | awk '{print $1}'
}

# Function to compare checksums
compare_checksums() {
    if [ "$1" == "$2" ]; then
        echo -e "${BLUE}Checksums match for $3. File integrity is confirmed.${NC}"
    else
        echo -e "${BLINK_RED}Checksums do not match for $3. File may be corrupted or tampered with.${NC}"
    fi
}

# Ask how many files to check
echo -e "${BLUE}How many files do you want to check?${NC}"
read file_count

# Validate input is a number
re='^[0-9]+$'
if ! [[ $file_count =~ $re ]] ; then
   echo -e "${BLINK_RED}Error: Not a number${NC}" >&2; exit 1
fi

# Initialize arrays
declare -a file_paths
declare -a checksums
declare -a original_checksums

# Loop through the number of files for path input
for (( i=1; i<=file_count; i++ ))
do
    echo -e "${BLUE}Enter the full path to file $i:${NC}"
    read file_path
    file_paths[i]=$file_path
done

# Generate checksums for all files
for (( i=1; i<=file_count; i++ ))
do
    checksums[i]=$(generate_checksum "${file_paths[i]}")
done

# Ask for original checksums for comparison
for (( i=1; i<=file_count; i++ ))
do
    echo -e "${BLUE}Enter the original checksum for file ${file_paths[i]}:${NC}"
    read original_checksum
    original_checksums[i]=$original_checksum
done

# Compare all checksums
for (( i=1; i<=file_count; i++ ))
do
    compare_checksums "${checksums[i]}" "${original_checksums[i]}" "${file_paths[i]}"
done

